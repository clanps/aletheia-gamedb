// SPDX-FileCopyrightText: 2025 Spencer
// SPDX-License-Identifier: AGPL-3.0-only

export component Scrollable inherits Rectangle {
  in property <bool> enabled: true;
  in property <color> scrollbar_track_color: #1e1e2e;
  in property <color> scrollbar_thumb_color: #45475a;
  in property <color> scrollbar_thumb_hover_color: #7678ed;
  in property <length> scrollbar_width: 12px;
  in-out property <length> viewport_height <=> flickable.viewport-height;
  in-out property <length> viewport_y <=> flickable.viewport-y;
  private property <bool> has_vertical_overflow: viewport_height > flickable.height;

  flickable := Flickable {
    width: parent.width;
    height: parent.height;
    interactive: root.enabled;
    @children
  }

  if root.has_vertical_overflow: Rectangle {
    y: 4px;
    x: parent.width - root.scrollbar_width - self.y;
    width: root.scrollbar_width;
    height: parent.height - self.y;

    Rectangle {
      width: 100%;
      height: 100%;
      background: root.scrollbar_track_color;
      border-radius: root.scrollbar_width / 2;
    }

    thumb := Rectangle {
      private property <float> scroll_ratio: -flickable.viewport-y / (flickable.viewport-height - flickable.height);
      private property <length> track_height: parent.height - parent.y;
      private property <length> thumb_height: max(20px, (flickable.height / flickable.viewport-height) * track_height);
      private property <length> thumb_y: self.x + scroll_ratio * (track_height - thumb_height);
      x: 2px;
      y: self.thumb_y;
      width: parent.width - parent.y;
      height: self.thumb_height;
      background: touch_area.has-hover ? root.scrollbar_thumb_hover_color : root.scrollbar_thumb_color;
      border-radius: (root.scrollbar_width - parent.y) / 2;

      animate background { duration: 150ms; }
    }

    touch_area := TouchArea {
      private property <length> press_start_y;
      private property <length> press_start_viewport_y;
      width: parent.width;
      height: parent.height;
      moved => {
        if (self.pressed) {
          flickable.viewport-y = max(
            flickable.height - flickable.viewport-height,
            min(0px,
              self.press_start_viewport_y -
              (self.mouse-y - self.press_start_y) *
              (flickable.viewport-height - flickable.height) /
              (parent.height - thumb.height - parent.y)
            )
          );
        }
      }
      pointer-event(event) => {
        if (event.kind == PointerEventKind.down) {
          self.press_start_y = self.mouse-y;
          self.press_start_viewport_y = flickable.viewport-y;
        }
      }
    }
  }
}
